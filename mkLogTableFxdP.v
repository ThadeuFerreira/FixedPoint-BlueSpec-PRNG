//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Wed Jul  4 22:01:57 -03 2018
//
//
// Ports:
// Name                         I/O  size props
// RDY_run                        O     1 const
// get                            O    65 reg
// RDY_get                        O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// run_input_val                  I    65
// EN_run                         I     1
// EN_get                         I     1 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkLogTableFxdP(CLK,
		      RST_N,

		      run_input_val,
		      EN_run,
		      RDY_run,

		      EN_get,
		      get,
		      RDY_get);
  input  CLK;
  input  RST_N;

  // action method run
  input  [64 : 0] run_input_val;
  input  EN_run;
  output RDY_run;

  // actionvalue method get
  input  EN_get;
  output [64 : 0] get;
  output RDY_get;

  // signals for module outputs
  wire [64 : 0] get;
  wire RDY_get, RDY_run;

  // register cycle
  reg [31 : 0] cycle;
  wire [31 : 0] cycle$D_IN;
  wire cycle$EN;

  // register flag
  reg flag;
  wire flag$D_IN, flag$EN;

  // register result
  reg [64 : 0] result;
  wire [64 : 0] result$D_IN;
  wire result$EN;

  // register x
  reg [64 : 0] x;
  wire [64 : 0] x$D_IN;
  wire x$EN;

  // rule scheduling signals
  wire CAN_FIRE_get, CAN_FIRE_run, WILL_FIRE_get, WILL_FIRE_run;

  // remaining internal signals
  wire [32 : 0] x_i__h298;
  wire [31 : 0] fval__h297, x__h5642, x_f__h299;
  wire [5 : 0] IF_run_input_val_BIT_31_THEN_0_ELSE_IF_run_inp_ETC___d66,
	       x__h5673;

  // action method run
  assign RDY_run = 1'd1 ;
  assign CAN_FIRE_run = 1'd1 ;
  assign WILL_FIRE_run = EN_run ;

  // actionvalue method get
  assign get = result ;
  assign RDY_get = 1'd1 ;
  assign CAN_FIRE_get = 1'd1 ;
  assign WILL_FIRE_get = EN_get ;

  // register cycle
  assign cycle$D_IN = cycle + 32'd1 ;
  assign cycle$EN = EN_run && flag ;

  // register flag
  assign flag$D_IN = !flag ;
  assign flag$EN = EN_run ;

  // register result
  assign result$D_IN = { x_i__h298, x_f__h299 } ;
  assign result$EN = EN_run && flag ;

  // register x
  assign x$D_IN = 65'h0 ;
  assign x$EN = 1'b0 ;

  // remaining internal signals
  assign IF_run_input_val_BIT_31_THEN_0_ELSE_IF_run_inp_ETC___d66 =
	     run_input_val[31] ?
	       6'd0 :
	       (run_input_val[30] ?
		  6'd1 :
		  (run_input_val[29] ?
		     6'd2 :
		     (run_input_val[28] ?
			6'd3 :
			(run_input_val[27] ?
			   6'd4 :
			   (run_input_val[26] ?
			      6'd5 :
			      (run_input_val[25] ?
				 6'd6 :
				 (run_input_val[24] ?
				    6'd7 :
				    (run_input_val[23] ?
				       6'd8 :
				       (run_input_val[22] ?
					  6'd9 :
					  (run_input_val[21] ?
					     6'd10 :
					     (run_input_val[20] ?
						6'd11 :
						(run_input_val[19] ?
						   6'd12 :
						   (run_input_val[18] ?
						      6'd13 :
						      (run_input_val[17] ?
							 6'd14 :
							 (run_input_val[16] ?
							    6'd15 :
							    (run_input_val[15] ?
							       6'd16 :
							       (run_input_val[14] ?
								  6'd17 :
								  (run_input_val[13] ?
								     6'd18 :
								     (run_input_val[12] ?
									6'd19 :
									(run_input_val[11] ?
									   6'd20 :
									   (run_input_val[10] ?
									      6'd21 :
									      (run_input_val[9] ?
										 6'd22 :
										 (run_input_val[8] ?
										    6'd23 :
										    (run_input_val[7] ?
										       6'd24 :
										       (run_input_val[6] ?
											  6'd25 :
											  (run_input_val[5] ?
											     6'd26 :
											     (run_input_val[4] ?
												6'd27 :
												(run_input_val[3] ?
												   6'd28 :
												   (run_input_val[2] ?
												      6'd29 :
												      (run_input_val[1] ?
													 6'd30 :
													 (run_input_val[0] ?
													    6'd31 :
													    6'd32))))))))))))))))))))))))))))))) ;
  assign fval__h297 = run_input_val[31:0] << x__h5673 ;
  assign x__h5642 = -fval__h297 ;
  assign x__h5673 =
	     IF_run_input_val_BIT_31_THEN_0_ELSE_IF_run_inp_ETC___d66 + 6'd1 ;
  assign x_f__h299 = x__h5642 - 32'd1 ;
  assign x_i__h298 =
	     { 27'd0,
	       IF_run_input_val_BIT_31_THEN_0_ELSE_IF_run_inp_ETC___d66 } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        cycle <= `BSV_ASSIGNMENT_DELAY 32'd0;
	flag <= `BSV_ASSIGNMENT_DELAY 1'd1;
	result <= `BSV_ASSIGNMENT_DELAY 65'd0;
	x <= `BSV_ASSIGNMENT_DELAY 65'd0;
      end
    else
      begin
        if (cycle$EN) cycle <= `BSV_ASSIGNMENT_DELAY cycle$D_IN;
	if (flag$EN) flag <= `BSV_ASSIGNMENT_DELAY flag$D_IN;
	if (result$EN) result <= `BSV_ASSIGNMENT_DELAY result$D_IN;
	if (x$EN) x <= `BSV_ASSIGNMENT_DELAY x$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cycle = 32'hAAAAAAAA;
    flag = 1'h0;
    result = 65'h0AAAAAAAAAAAAAAAA;
    x = 65'h0AAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkLogTableFxdP

